<!DOCTYPE html>
<html>

<head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8">
    <title>Stupid Snake</title>

    <script id="vertex-shader" type="x-shader/x-vertex">
attribute vec4 vPosition;
attribute vec4 vColor;
uniform vec2 posMan;
uniform vec2 direction;
uniform vec2 predirection;
varying vec4 fColor;

void
main()
{
    gl_Position.x = vPosition.x + posMan.x - predirection.x*0.1;
    gl_Position.y = vPosition.y + posMan.y - predirection.y*0.1;
    gl_Position.z = 0.0;
    gl_Position.w = 1.0;
    fColor = vColor;
}
</script>

<script id="fragment-shader" type="x-shader/x-fragment">

precision mediump float;
uniform int drawingType;
varying vec4 fColor;

void
main()
{
    gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
    
    //gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
    
    if(drawingType==0){
        gl_FragColor = fColor;
    }
    
    if(drawingType==1){
        gl_FragColor = vec4( 0.0, 1.0, 0.0, 1.0 );
    }
    
    if(drawingType==2){
       gl_FragColor = vec4( 0.0, 0.5, 0.0, 1.0 );
    }

}
</script>

    <script type="text/javascript" src="./Common/webgl-utils.js"></script>
    <script type="text/javascript" src="./Common/initShaders.js"></script>
    <script type="text/javascript" src="./Common/MV.js"></script>
    <!--<script type="text/javascript" src="Snake_ANS.js"></script> -->
    <script>
        var canvas;
        var gl;
        var btn_gizmo;
        
        var posManLoc, posMan = vec2(0, 0);
        var pre_directLoc;
        var snake = [vec2(0,0),vec2(0,0),vec2(0,0)];
        var foods = [];
        var pre_direction = [vec2(0,0),vec2(0,0)];
        var snakeStartLength = 3;
        var snakeLengthCache = 3;
        var map;
        var mapSize = 19;
        
        var drawingType; //  0: Snake, 1: Food, 2: Gizmo
        
        var isGizmoOpen = false;

        var colors = [
            vec4(0.0, 0.0, 1.0, 1.0), // blue
            vec4(0.0, 1.0, 1.0, 1.0), // cyan
            vec4(1.0, 0.0, 1.0, 1.0), // magenta
            vec4(0.0, 1.0, 1.0, 1.0) // cyan
        ];

        var vertices = [
            vec2(-0.05, -0.05),
            vec2(-0.05, 0.05),
            vec2(0.05, 0.05),
            vec2(0.05, -0.05)
        ];

        window.onload = function init() {
            
            InitMap();
            canvas = document.getElementById("gl-canvas");
            btn_gizmo = document.getElementById("btn_gizmo");

            gl = WebGLUtils.setupWebGL(canvas);
            if (!gl) {
                alert("WebGL isn't available");
            }

            //  Configure WebGL
            gl.viewport(0, 0, canvas.width, canvas.height);
            gl.clearColor(0.0, 0.0, 0.0, 1.0);

            //  Load shaders and initialize attribute buffers
            var program = initShaders(gl, "vertex-shader", "fragment-shader");
            gl.useProgram(program);

            // Load the data into the GPU
            var vBufferId = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, vBufferId);
            gl.bufferData(gl.ARRAY_BUFFER, flatten(vertices), gl.STATIC_DRAW);

            // Associate out shader variables with our data buffer
            var vPosition = gl.getAttribLocation(program, "vPosition");
            gl.vertexAttribPointer(vPosition, 2, gl.FLOAT, false, 0, 0);
            gl.enableVertexAttribArray(vPosition);

            var cBufferID = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, cBufferID);
            gl.bufferData(gl.ARRAY_BUFFER, flatten(colors), gl.STATIC_DRAW);

            var vColor = gl.getAttribLocation(program, "vColor");
            gl.vertexAttribPointer(vColor, 4, gl.FLOAT, false, 0, 0);
            gl.enableVertexAttribArray(vColor);

            posManLoc = gl.getUniformLocation(program, "posMan");
            pre_directLoc = gl.getUniformLocation(program, "predirection");
            drawingType = gl.getUniformLocation(program, "drawingType");

            window.onkeydown = function(event) {
                var key = String.fromCharCode(event.keyCode);

                switch (key) {
                    case 'w':
                    case 'W':
                        if (posMan[1] > 0.89) break;
                        posMan[1] += 0.1;
                        DebugInformation();
                        SetPreDirection(vec2(0, 1));
                        //pre_direct = direct;
                        //direct = vec2(0, 1);
                        break;

                    case 'a':
                    case 'A':
                        if (posMan[0] < -0.89) break;
                        posMan[0] -= 0.1;
                        DebugInformation();
                        SetPreDirection(vec2(-1, 0));
                        //pre_direct = direct;
                        //direct = vec2(-1, 0);
                        break;

                    case 's':
                    case 'S':
                        if (posMan[1] < -0.89) break;
                        posMan[1] -= 0.1;
                        DebugInformation();
                        SetPreDirection(vec2(0, -1));
                        //pre_direct = direct;
                        //direct = vec2(0, -1);
                        break;

                    case 'd':
                    case 'D':
                        if (posMan[0] > 0.89) break;
                        posMan[0] += 0.1;
                        DebugInformation();
                        SetPreDirection(vec2(1, 0));
                        //pre_direct = direct;
                        //direct = vec2(1, 0);
                        break;
                }
            };
            
            canvas.addEventListener("click",SetFood,false);
            
            btn_gizmo.addEventListener("click",function(){
                isGizmoOpen = !isGizmoOpen;
            },false);
            
            render();
        };

        function render() {
            gl.clear(gl.COLOR_BUFFER_BIT);

            RenderBody();
            RenderFood();
            
            if(isGizmoOpen){
                DrawMapGizmo();
            }

            window.requestAnimFrame(render);
        }
        
        function DebugInformation() {
            var posManX = Math.round(posMan[0]*10);
            var posManY = Math.round(posMan[1]*10);
            var MapposManX = posManX + ((mapSize-1)/2);
            var MapposManY = (posManY - ((mapSize-1)/2)) * -1;
            console.log("MapposManX: " + MapposManX + " MapposManY: " + MapposManY);
            console.log("posManX: " + posManX + " posManY: " + posManY + " Mapid: " + (MapposManX + (MapposManY * (mapSize-1))));
            
            console.log(CheckDestination(MapposManX,MapposManY));
        }
        
        //
        // InitMap :
        // initialize the map content.
        //
        
        function InitMap(){
            var tempMap = [];
            for(var i = 0; i< mapSize; i++){
                var tempMapChild = [];
                for(var j = 0; j < mapSize; j++){
                    // status  1: Snake 2: Food 3: empty
                    var temp = {id:(i*(mapSize-1))+i+j, status: 3};
                    tempMapChild.push(temp);
                }
                tempMap.push(tempMapChild);
            }
            
            map = tempMap;
        }
        
        function RenderBody() {
            var index,i;
            
            gl.uniform2fv(posManLoc, posMan);
            gl.uniform1i(drawingType,0);
            
            for(index = 0; index< snakeLengthCache; index++) {
                var Tdir = vec2(0,0); // Target direction
                for(i=0; i<index;i++){
                    Tdir[0] += pre_direction[i][0];
                    Tdir[1] += pre_direction[i][1];
                }
                gl.uniform2fv(pre_directLoc, Tdir);
                gl.drawArrays(gl.TRIANGLE_FAN, 0, 4);
            }
        }
        
        //
        // CheckDestination :
        // Check the destination status.
        //
        
        function CheckDestination(x,y){
            if(map[x][y].status == 0){
                return 0; // snake
            }
            else if(map[x][y].status == 1){
                AddBody();
                return 1; // food
            }
            else {
                return 2; // empty
            }
        }
        
        //
        // AddBody :
        // Add the new body for the snake.
        //
        
        function AddBody() {
            snakeLengthCache++;
            pre_direction.push(vec2(0,0));
        }
        
        //
        // SetPreDirection : 
        // Add direction to the frist element of the pre direction array
        // If it is out of snake length, then pop the last one out.
        //
        
        function SetPreDirection(dir){
            
            pre_direction.unshift(dir);
            
            
            while(pre_direction.length>snakeLengthCache - 1){
                pre_direction.pop();
            }
        }
        
        function SetFood(event){
            var PosX = -1 + 2*event.clientX/canvas.width;
            var PosY = -1 + 2*(canvas.height-event.clientY)/canvas.height  + 0.1; // 0.1 為誤差
            var NewPosX = Math.floor(PosX *10);
            var NewPosY = Math.floor(PosY *10);
            
            console.log("x:" + NewPosX + " y:" + NewPosY);
            
            if(foods== null){
                foods.push(vec2(-NewPosX,-NewPosY));
            }
            else {
                if(!foods.includes(vec2(-NewPosX,-NewPosY))){
                    foods.push(vec2(-NewPosX,-NewPosY));
                }
            }
            
            var MapPosX = NewPosX + ((mapSize-1)/2);
            var MapPosY = (NewPosY - ((mapSize-1)/2)) * -1;
            
            console.log("foodX: " + MapPosX + " foodY: " + MapPosY);
            
            map[MapPosX][MapPosY].status = 1;
            
        }
        
        function CheckFoodExist(){
            
        }
        
        function RenderFood(){
            if(foods!= null && foods[0] != null){
                gl.uniform2fv(posManLoc, vec2(0,0));
                gl.uniform1i(drawingType,1);
                for (var i = 0; i < foods.length;i++) {
                    gl.uniform2fv(pre_directLoc, foods[i]);
                    gl.drawArrays(gl.TRIANGLE_FAN, 0, 4);
                }
            }
        }
        
        function DrawMap() {
            
            for(var i = 0; i< mapSize; i++){
                for(var j = 0; j < mapSize; j++){
                    // status  1: Snake 2: Food 3: empty
                    gl.uniform2fv(posManLoc, vec2(i,j));
                    switch(map[i][j].status){
                        case 0:
                            gl.drawArrays(gl.TRIANGLE_FAN, 0, 4);
                            break;
                        case 1:
                            gl.drawArrays(gl.TRIANGLE_FAN, 0, 4);
                            break;
                        case 2:
                            gl.drawArrays(gl.LINE_LOOP, 0, 4);
                            break;
                        default:
                            break;
                    }
                }
            }
        }
        
        function DrawMapGizmo(){
            var Hindex,Vindex,i; // Horizontal and Vertical
            
            gl.uniform2fv(posManLoc, vec2(0,0));
            gl.uniform1i(drawingType,2);
            
            for(Hindex = -9; Hindex < 10; Hindex++) {
                for(Findex = -9; Findex < 10; Findex++){
                    var Tdir = vec2(Hindex,Findex); // Target direction
                    gl.uniform2fv(pre_directLoc, Tdir);
                    gl.drawArrays(gl.LINE_LOOP, 0, 4);
                }
            }
        }

    </script>
</head>

<body>
    <canvas id="gl-canvas" width="512" height="512">
Oops ... your browser doesn't support the HTML5 canvas element
</canvas>
<br>
<button id="btn_gizmo">Map Gizmo (On / Off)</button>
</body>

</html>

<!-- TODO: 可用滑鼠點擊畫面出現彩色食物(三角形, 顏色會變化, 可多個, 點在蛇身上無效, 點擊後食物會剛好出現在蛇可以走的格子上) 30分 -->
<!-- TODO: 可移動蛇吃食物，蛇吃了後會變長一格，並且變成該食物的顏色 20分 -->
<!-- TODO: 蛇不可以穿過自己的身體，碰撞後使用者仍可往其他方向移動不會死掉 20分 -->
<!-- TODO: 新增 Gizmo  -->
